import Image from "next/image";
import { Callout } from "nextra/components";

## Accessibility

<Callout type="info">
  This Section is a Partial that be reused in multiple pages. For example, in
  the Web and Mobile component pages.
</Callout>

Buttons can have different states that are visually and programmatically conveyed

- Use the ariaControls prop to add an aria-controls attribute to the button. Use the attribute to point to the unique id of the content that the button manages.
- If a button expands or collapses adjacent content, then use the ariaExpanded prop to add the aria-expanded attribute to the button. Set the value to convey the current expanded (true) or collapsed (false) state of the content.
- Use the disabled prop to set the disabled state of the button. This prevents users from being able to interact with the button, and conveys its inactive state to assistive technologies.
- Use the pressed prop to add an aria-pressed attribute to the button.

### Keyboard support

Buttons use browser defaults for keyboard interactions.

Give buttons keyboard focus with the tab key (or shift + tab when tabbing backwards)
Activate buttons with the enter/return key or the space key

<Image
  src="https://placehold.co/600x400"
  alt="Demo"
  width={600}
  height={400}
  style={{ margin: "2rem auto" }}
/>

When the button has focus:

“Space”: Activates the button.

“Enter”: Activates the button.

Following button activation, focus is set depending on the type of action the button performs. For example:

If activating the button opens a dialog, the focus moves inside the dialog.

If activating the button closes a dialog, focus typically returns to the button that opened the dialog unless the function performed in the dialog context logically leads to a different element. For example, activating a cancel button in a dialog return focus to the button that opened the dialog. However, if the dialog were confirming the action of deleting the page from which it was opened, the focus would logically move to a new context.

If activating the button does not dismiss the current context, then focus typically remains on the button after activation, e.g., an Apply or Recalculate button.

If the button action indicates a context change, such as move to next step in a wizard or add another search criteria, then it is often appropriate to move focus to the starting point for that action.

If the button is activated with a shortcut key, the focus usually remains in the context from which the shortcut key was activated. For example, if Alt + U were assigned to an "Up" button that moves the currently focused item in a list one position higher in the list, pressing Alt + U when the focus is in the list would not move the focus from the list.

### WAI-ARIA Roles, States, and Properties

<Image
  src="https://placehold.co/600x400"
  alt="Demo"
  width={600}
  height={400}
  style={{ margin: "2rem auto" }}
/>

The button has role of button.

The button has an accessible label. By default, the accessible name is computed from any text content inside the button element. However, it can also be provided with aria-labelledby or aria-label.

If a description of the button's function is present, the button element has aria-describedby set to the ID of the element containing the description.

When the action associated with a button is unavailable, the button has aria-disabled set to true.

If the button is a toggle button, it has an aria-pressed state. When the button is toggled on, the value of this state is true, and when toggled off, the state is false.

#### Custom key events

Use the `onKeyDown`, `onKeyPress`, and `onKeyUp` props to create custom events for buttons. With these props, you can use buttons to create complex, custom interactions like drag-and-drop interfaces.

Since these props introduce non-standard features to buttons, make sure to include accessible instructions so that users can understand how to use these features.
